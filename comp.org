#+TITLE:  Completion framework for Elvish
#+AUTHOR: Diego Zamboni
#+EMAIL:  diego@zzamboni.org

This module provides a few handy functions that make it easier to define completions in Elvish.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy to explain. See [[file:comp.elv][comp.elv]] for the generated file.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
  - [[#compitem-def-cmd][comp:item $def @cmd]]
  - [[#compsequence-def-cmd][comp:sequence $def @cmd]]
  - [[#compsubcommands-def-cmd][comp:subcommands $def @cmd]]
  - [[#utility-functions][Utility functions]]
- [[#implementation][Implementation]]
  - [[#utility-functions-1][Utility functions]]
  - [[#completion-functions][Completion functions]]
  - [[#completion-wrapper-functions][Completion wrapper functions]]

* Usage

Install the =elvish-completions= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-completions
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/comp
#+end_src

The following functions are available for you to provide completions. All of them receive two arguments:

- A "completion definition", which in general, indicates how the completions will be produced. The structure of this definition depends on the function, and they are documented below.
- The contents of the command line so far, as passed to the [[https://elvish.io/ref/edit.html#argument-completer][argument completer functions]].

Each function returns any available completions according to its definitions, which will then be offered by Elvish to the user.

*Note:* all functions have an equivalent with the name ending in =-wrapper=, which receives only the definition argument and which return a /function/ which can be assigned directly to the corresponding elements of =$edit:completion:arg-completer=. See below for examples.

** comp:item $def @cmd

This is the basic building block of the framework. It receives a single completion definition item, which can be one of the following:

- An array containing all the potential completions (the array can be empty, in which case no completions are provided).
- A function which returns the potential completions (it can return nothing, in which case no completions are provided). The function should have one of the following arities, which affect which arguments will be passed to it:
  - If it takes no arguments, no arguments are passed to it
  - If it takes only a single argument, it gets the current (last) component of the command line =@cmd=
  - If it takes only a rest argument, it gets the full current command line (the contents of =@cmd=)

Example: you can build a simple completer for =cd= like this:

#+begin_src elvish
use github.com/zzamboni/elvish-completions/comp
fn complete-dirs [arg]{ put $arg* | each [x]{ if (-is-dir $x) { put $x } } }
edit:completion:arg-completer[cd] = [@cmd]{ comp:item $complete-dirs~ $@cmd }
#+end_src

(I defined the =complete-dirs= function separately only for clarity - you can also embed the lambda directly as an argument to =comp:item=)

In simple cases like the above, you can use the =comp:item-wrapper= function to avoid defining the wrapper function by hand:

#+begin_src elvish
edit:completion:arg-completer[cd] = (comp:item-wrapper $complete-dirs~)
#+end_src

** comp:sequence $def @cmd

=comp:sequence= builds upon =comp:item= to allow specifying a /sequence of items/ as the completion definition, including support for command-line options at the beginning of the command. The definition in this case has to be a map with two indices:

- =-seq= (mandatory) containing an array of definition items, which will be applied depending on their position within the command parameter sequence. The last element of the list is repeated for all later arguments. If no completions should be provided past the last argument, you can use =$nop~= as the last element of the definition list.
- =-opts= (optional) may contain a single definition item which produces a list of command-line options that are allowed at the beginning of the command, when no other arguments have been provided.

*Note:* the algorithm used at the moment for identifying command-line options only works correctly with options which start with a dash and which do not have space-separated values (e.g. =--option=value= works, =--option value= does not). This will be fixed in an upcoming version.

*Example #1:* you can improve on the previous completer for =cd= by preventing more than one argument from being completed (only the first argument will be completed using =complete-dirs=, all others will be completed using =nop=, which provides no completions):

#+begin_src elvish
  edit:completion:arg-completer[cd] = [@cmd]{ comp:sequence [
      &-seq= [ $complete-dirs~ $nop~ ]
  ] $@cmd }
#+end_src

*Example #2:* a simple completer for =ls= with a subset of its options, and using =comp:sequence-wrapper= (note that =-l= and =-R= are only provided as completions when you have not typed any filenames yet):

#+begin_src elvish
  edit:completion:arg-completer[ls] = (comp:sequence-wrapper [
      &-opts= [ -l -R ]
      &-seq= [ [arg]{ put $arg* } ]
  ])
#+end_src

*Example #3:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/ssh.org][ssh completer]].

** comp:subcommands $def @cmd

The =comp:subcommands= function builds upon =comp:sequence= to provide subcomand-completion for commands such as =git=.  In this case, the definition is a map containing the subcommand completion definitions. Each index is a subcommand, and its value is a completion sequence as accepted by =comp:sequence= (each sequence must only correspond to the arguments of its corresponding subcommand). The map may also contain an entry with the index =-opts= containing a single item definition to generate any available top-level options (to appear before a subcommand).

*Example #1:* a simple completer for the =brew= package manager, with support for installing and uninstalling packages. =install= gets as completions all available packages, while =uninstall= only completes installed packages. Note that for both subcommands we automatically extract command-line options . Also note that all =-opts= elements get initialized at definition time (they are arrays), whereas the =-seq= completions get evaluated at runtime (they are lambdas), to automatically update according to the current packages.

#+begin_src elvish
  brew-completions = [
    &-opts= [ --version ]
    &install= [
      &-opts= [ (re:find '(--\w[\w-]*)' (brew install -h | head -1))[groups][1][text] ]
      &-seq= [ { brew search } ]
    ]
    &uninstall= [
      &-opts= [ (re:find '(--\w[\w-]*)' (brew uninstall -h | head -1))[groups][1][text] ]
      &-seq= [ { brew list } ]
    ]
  ]

  edit:completion:arg-completer[brew] = (comp:subcommands-wrapper $brew-completions)
#+end_src

*Example #2:* See the [[https://github.com/zzamboni/elvish-completions/blob/master/git.org][git completer]].

** Utility functions

=comp:decorate= maps its input through =edit:complex-candidate= with the given options. Can be passed the same options as [[https://elvish.io/ref/edit.html#argument-completer][edit:complex-candidate]]. In addition, if =&suffix= is specified, it is used to set both =&display-suffix= and =&code-suffix=.

*Example:* the =brew= completer shown before can be made to show package names and command-line options in different styles. Note how =comp:decorate= can get its arguments both as arguments (in the =-opts= assignments) and as pipeline input (in =-seq=).

#+begin_src elvish
  brew-completions = [
    &-opts= [ --version ]
    &install= [
      &-opts= [ (comp:decorate &style=blue (re:find '(--\w[\w-]*)' (brew install -h | head -1))[groups][1][text]) ]
      &-seq= [ { brew search | comp:decorate &style=green } ]
    ]
    &uninstall= [
      &-opts= [ (comp:decorate &style=blue (re:find '(--\w[\w-]*)' (brew uninstall -h | head -1))[groups][1][text]) ]
      &-seq= [ { brew list | comp:decorate &style=red } ]
    ]
  ]

  edit:completion:arg-completer[brew] = (comp:subcommands-wrapper $brew-completions)
#+end_src

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

#+begin_src elvish
  use re
  use github.com/zzamboni/elvish-modules/util
#+end_src

** Utility functions

=comp:decorate= maps its input through =edit:complex-candidate= with the given options. Can be passed the same options as [[https://elvish.io/ref/edit.html#argument-completer][edit:complex-candidate]]. In addition, if =&suffix= is specified, it is used to set both =&display-suffix= and =&code-suffix=.

#+begin_src elvish
  fn decorate [&code-suffix='' &display-suffix='' &suffix='' &style='' @input]{
    if (eq (count $input) 0) {
      input = [(all)]
    }
    if (not-eq $suffix '') {
      display-suffix = $suffix
      code-suffix = $suffix
    }
    each [k]{
      edit:complex-candidate &code-suffix=$code-suffix &display-suffix=$display-suffix &style=$style $k
    } $input
  }
#+end_src

** Completion functions

=comp:item= expands a single element into its completion values. If it's a function, it gets executed. If it's a list, it's exploded.

If the completion item is a function, the arguments that get passed to it depend on its signature:

- If it receives no arguments, no arguments are passed
- If it receives a single argument, it gets the current component of the command line
- If it receives a rest argument, it receives the full current command line

#+begin_src elvish
  fn item [def @cmd]{
    arg = $cmd[-1]
    what = (kind-of $def)
    if (eq $what 'fn') {
      fnargs = [ (count $def[arg-names]) (not-eq $def[rest-arg] '') ]
      if (eq $fnargs [ 0 $false ]) {
        $def
      } elif (eq $fnargs [ 1 $false ]) {
        $def $arg
      } elif (eq $fnargs [ 0 $true ]) {
        $def $@cmd
      }
    } elif (eq $what 'list') {
      explode $def
    }
  }
#+end_src

=comp:sequence= receives a definition array and the current contents of the command line. The first element of =$cmd= is the command, and it should not be included in the definition.

#+begin_src elvish
  fn sequence [def @cmd]{
    n = (count $cmd)
    cmd-wo = [(each [p]{ if (not (re:match "^-" $p)) { put $p } } $cmd)]
    n-wo = (count $cmd-wo)
    if (and (eq $n-wo 2) (has-key $def -opts)) {
      item $def[-opts] $@cmd
    }
    item $def[-seq][(util:min (- $n-wo 2) (- (count $def[-seq]) 1))] $@cmd
  }
#+end_src

=comp:subcommands= receives a definition map and the current contents of the command line.

#+begin_src elvish
  fn subcommands [def @cmd]{
    n = (count $cmd)
#+end_src

If completion for the top-level subcommand is expected (=eq $n 2=), the top-level indices plus the global options (if provided in the =-opts= element).

#+begin_src elvish
    if (eq $n 2) {
      keys (dissoc $def -opts)
      if (has-key $def -opts) {
        item $def[-opts] $@cmd
      }
#+end_src

Otherwise, depending on the subcommand already provided, the corresponding element of the corresponding definition list is expanded. If the element is a string, it is considered and alias, so we call =subcommands= with the target command.

#+begin_src elvish
    } else {
      subcommand = $cmd[1]
      if (has-key $def $subcommand) {
        if (eq (kind-of $def[$subcommand]) 'string') {
          subcommands $def $cmd[0] $def[$subcommand] (explode $cmd[2:])
        } else {
          sequence $def[$subcommand] (explode $cmd[1:])
        }
      }
    }
  }
#+end_src

** Completion wrapper functions

The wrapper functions receive only the =$def= argument, and return a /function/ which takes the current command and call the corresponding completion function with the correct arguments. We have a wrapper-generator function which takes the function to call and returns the appropriate wrapper function. Very meta.

#+begin_src elvish
  fn -wrapper-gen [func]{
    put [def]{ put [@cmd]{ $func $def $@cmd } }
  }
#+end_src

#+begin_src elvish
item-wrapper~ = (-wrapper-gen $item~)
sequence-wrapper~ = (-wrapper-gen $sequence~)
subcommands-wrapper~ = (-wrapper-gen $subcommands~)
#+end_src
