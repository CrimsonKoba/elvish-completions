#+title: Elvish completions for git
#+author: Diego Zamboni
#+email: diego@zzamboni.org

This module implements completions for =git= or for tools which allow git commands to be passed, like =vcsh=.

Some original inspiration from https://github.com/occivink/config/blob/master/.elvish/rc.elv.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
- [[#implementation][Implementation]]
  - [[#libraries-and-global-variables][Libraries and global variables]]
  - [[#configuration-variables][Configuration variables]]
  - [[#utility-functions][Utility functions]]
  - [[#initialization-of-completion-definitions][Initialization of completion definitions]]

* Usage

Install the =elvish-completions= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-completions
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/git
#+end_src

Now you can type =git<space>=, press ~Tab~ and see the corresponding completions. All =git= commands are automatically completed with their options (automatically extracted from their help messages). Some commands get more specific completions, including =add=, =push=, =checkout=, =diff= and a few others. Git aliases are automatically detected as well. Aliases which point to a single =git= command are automatically completed like the original command.

Several components are colorized, you can configure the styles by setting these variables (default values shown):

#+begin_src elvish
  comp:modified-style  = yellow
  comp:untracked-style = red
  comp:tracked-style   = ''
  comp:branch-style    = blue
  comp:remote-style    = cyan
#+end_src

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

** Libraries and global variables

We first load a number of libraries, including =comp=, the Elvish completion framework.

#+begin_src elvish
  use ./comp
  use re
  use github.com/muesli/elvish-libs/git
  use github.com/zzamboni/elvish-modules/util
#+end_src

This is where the big completion-definition map will get build up progressively below.

#+begin_src elvish
  completions = [&]
#+end_src

We store the output of =git:status= in a global variable to make it easier to access by the different completion functions.

#+begin_src elvish
  status = [&]
#+end_src

** Configuration variables

The =$*-style= variables contains the style (as per =edit:styled=) to use for different completion components the completion menu. Set to =''= (an empty string) to show in the normal style.

#+begin_src elvish
  modified-style  = yellow
  untracked-style = red
  tracked-style   = ''
  branch-style    = blue
  remote-style    = cyan
#+end_src

** Utility functions

The =-run-git-cmd= function executes a git-like command, with the given arguments.  =$gitcmd= can be a single command, a multi-word command or a function and still be executed correctly. We cannot simply run =$gitcmd $@rest= because Elvish always interprets the first token (the head) to be the command.  One example of a multi-word =$gitcmd= is ="vcsh <repo>"=, after which any git subcommand is valid.

#+begin_src elvish
  fn -run-git-cmd [gitcmd @rest]{
    gitcmds = [$gitcmd]
    if (eq (kind-of $gitcmd) string) {
      gitcmds = [(splits " " $gitcmd)]
    }
    cmd = $gitcmds[0]
    if (eq (kind-of $cmd) string) {
      cmd = (external $cmd)
    }
    $cmd (explode $gitcmds[1:]) $@rest
  }
#+end_src

The =-git-opts= function receives an optional git command, runs =git [command] -h= and parses the output to extract the command line options. The parsing is done with =comp:extract-opts=, but we pre-process the output to join options whose descriptions appear in the next line.

#+begin_src elvish
  fn -git-opts [@cmd]{
    -line = ''
    regex = '(?:-(\w),?\s*)?(?:--([\w-]+).*?)?\s\s(\w.*)$'
    if (eq $cmd []) {
      regex = '()--(\w[\w-]*)()'
    }
    _ = ?(git $@cmd -h 2>&1) | drop 1 | each [l]{
      if (re:match '^\s+\w' $l) {
        put $-line$l
        -line = ''
      } else {
        put $-line
        -line = $l
      }
    } |
    comp:extract-opts &regex=$regex
  }
#+end_src

We define the functions that return different possible values used in the completions. Some of these functions assume that =$status= contains already the output from =git:status=, which gets executed as the pre-hook of the git completer function below.

#+begin_src elvish
  fn MODIFIED      { explode $status[local-modified] | comp:decorate &style=$modified-style }
  fn UNTRACKED     { explode $status[untracked] | comp:decorate &style=$untracked-style }
  fn MOD-UNTRACKED { MODIFIED; UNTRACKED }
  fn TRACKED       { _ = ?(-run-git-cmd git ls-files 2>/dev/null) | comp:decorate &style=$tracked-style }
  fn BRANCHES      [&all=$false]{
    -allarg = []
    if $all { -allarg = ['--all'] }
    _ = ?(-run-git-cmd git branch --list (explode $-allarg) --format '%(refname:short)' 2>/dev/null |
  comp:decorate &display-suffix=' (branch)' &style=$branch-style) }
  fn REMOTES       { _ = ?(-run-git-cmd git remote 2>/dev/null | comp:decorate &style=$remote-style ) }
#+end_src

** Initialization of completion definitions

In this section we initialize the =$completions= map with the necessary data structure for =comp:subcommands= to provide the completions. We extract as much information as possible automatically from =git= itself.

First, we store in =$git-completions= the specialized completions for some git commands. Each sequence is a list of functions which return the possible completions at that point in the command. The =...= as a last element in some of them indicates that the last completion function is repeated for all further argument positions. The completion can also be a string, in which case it means an alias for some other command.

#+begin_src elvish
git-completions = [
  &add=      [ $MOD-UNTRACKED~ ... ]
  &stage=    add
  &checkout= [ { MODIFIED; BRANCHES } ... ]
  &mv=       [ $TRACKED~ ... ]
  &rm=       [ $TRACKED~ ... ]
  &diff=     [ { MODIFIED; BRANCHES  } ... ]
  &push=     [ $REMOTES~ { BRANCHES &all } ]
  &merge=    [ $BRANCHES~ ... ]
  &init=     [ [stem]{ put "."; comp:files $stem &dirs-only } ]
  &branch=   [ $BRANCHES~ ... ]
]
#+end_src

Next , we fetch the list of valid git commands from the output of =git help -a=, and store the corresponding completion sequences in =$completions=. All of them are configured to produce  completions for their options, as extracted by the =-git-opts= function. Those which have corresponding definitions in =$git-completions= get assigned those.

#+begin_src elvish
  git help -a | eawk [line @f]{ if (re:match '^  [a-z]' $line) { put $@f } } | each [c]{
    seq = [ ]
    if (has-key $git-completions $c) {
      seq = $git-completions[$c]
    }
    if (eq (kind-of $seq 'string')) {
      completions[$c] = $seq
    } else {
      completions[$c] = (comp:sequence $seq &opts={ -git-opts $c })
    }
  }
#+end_src

Next, we parse the defined aliases from the output of =git config --list=. We store the aliases in =completions= as well, but we check if an alias points to another valid command. In this case, we store the name of the target command as its value, which =comp:expand= interprets as "use the completions from the target command". If an alias does not expand to another existing command, we set up its completions as empty.

#+begin_src elvish
  git config --list | each [l]{ re:find '^alias\.([^=]+)=(.*)$' $l } | each [m]{
    alias target = $m[groups][1 2][text]
    if (has-key $completions $target) {
      completions[$alias] = $target
    } else {
      completions[$alias] = (comp:sequence [])
    }
  }
#+end_src

We setup the completer by assigning the function to the corresponding element of =$edit:completion:arg-completer=.

#+begin_src elvish
  edit:completion:arg-completer[git] = (comp:subcommands $completions \
    &pre-hook=[@_]{ status = (git:status) } &opts={ -git-opts }
  )
#+end_src
