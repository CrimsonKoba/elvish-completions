#+title: Elvish completions for git
#+author: Diego Zamboni
#+email: diego@zzamboni.org

This module implements completions for =git= or for tools which allow git commands to be passed, like =vcsh=.

Some original inspiration from https://github.com/occivink/config/blob/master/.elvish/rc.elv.

* Table of Contents                                            :TOC:noexport:
- [[#usage][Usage]]
- [[#implementation][Implementation]]

* Usage

Install the =elvish-completions= package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish
  use epm
  epm:install github.com/zzamboni/elvish-completions
#+end_src

In your =rc.elv=, load this module:

#+begin_src elvish
  use github.com/zzamboni/elvish-completions/git
#+end_src

* Implementation
:PROPERTIES:
:header-args:elvish: :tangle (concat (file-name-sans-extension (buffer-file-name)) ".elv")
:header-args: :mkdirp yes :comments no
:END:

We fetch the list of valid git commands and aliases from git itself, so that it is automatically up to date. We store aliases separately so we can check their definitions and use the completions for the corresponding commands when appropriate, but generate a big list with everything for the full completion.

#+begin_src elvish
  use ./comp
  use re
  use github.com/muesli/elvish-libs/git
  use github.com/zzamboni/elvish-modules/util

  -cmds = [ (git help -a | eawk [line @f]{ if (re:match '^  [a-z]' $line) { put $@f } }) ]
  aliases = [(git config --list | each [line]{
        if (re:match '^alias\.' $line) { re:replace '^alias\.([^=]+)=.*$' '${1}' $line }
  })]
  commands = [$@-cmds $@aliases]
  status = [&]
#+end_src

The =-run-git-cmd= function executes a git-like command, with the given arguments.  =$gitcmd= can be a multi-word command and still be executed correctly. We cannot simply run =$gitcmd $@rest= because Elvish always interprets the first token (the head) to be the command.  One example of a multi-word =$gitcmd= is ="vcsh <repo>"=, after which any git subcommand is valid.

#+begin_src elvish
  fn -run-git-cmd [gitcmd @rest]{
    gitcmds = [$gitcmd]
    if (eq (kind-of $gitcmd) string) {
      gitcmds = [(splits " " $gitcmd)]
    }
    cmd = $gitcmds[0]
    if (eq (kind-of $cmd) string) {
      cmd = (external $cmd)
    }
    if (> (count $gitcmds) 1) {
      $cmd (explode $gitcmds[1:]) $@rest
    } else {
      $cmd $@rest
    }
  }
#+end_src

We define the functions that return different possible values for completions.

#+begin_src elvish
  fn MODIFIED-FILES  { explode $status[local-modified] }
  fn UNTRACKED-FILES { explode $status[untracked] }
  fn TRACKED-FILES   { git ls-files }
  fn BRANCHES        { git branch --list --all --format '%(refname:short)' }
  fn REMOTES         { git remote }
#+end_src


The =$git-completions= variable contains the git subcommands for which we have completions. Each element is indexed by the git subcommand, and its value is a sequence of functions which return the possible completions at that point in the command.

#+begin_src elvish
  git-completions = [
    &-opts= [
      (git --help | each [l]{
          re:find '(--\w[\w-]*)' $l; re:find '[^-](-\w)\W' $l
      })[groups][1][text]]
    &add=      [ { MODIFIED-FILES; UNTRACKED-FILES } ]
    &stage=    add
    &checkout= [ { MODIFIED-FILES; BRANCHES }        ]
    &mv=       [ $TRACKED-FILES~                     ]
    &rm=       mv
    &diff=     rm
    &push=     [ $REMOTES~ $BRANCHES~                ]
    &merge=    [ $BRANCHES~                          ]
  ]
#+end_src

#+begin_src elvish
  fn git-completer [gitcmd @rest]{
    status = (git:status)
    comp:subcommands $git-completions $gitcmd $@rest
  }

  edit:completion:arg-completer[git] = $git-completer~
#+end_src
